# 📌 인상 깊었던 내용

## **📚 리팩토링**

> 할 일이 없어서 시간이 남아 도는 것이 아니라면, 특별한 이유도 없이 코드를 열어서 재정리하는 일은 아무런 의미가 없다.
…
레시 코드를 대상으로 작업할 때는 최소한 수정한 부분만큼은 원래 보다 깨끗하게 만들어 놓아야 한다.
…
새롭게 추가할 기능이 레거시 코드에 큰 영향을 준다면 사전에 영향이 가해지는 부분을 리펙토링하는 것이 바람직하다
>
>
> 📕 292p 20번째 (15장)
>

### **🧐 : 리팩토링에 대한 사유가 주관적인 사유보다는 객관적으로 모두가 동의할 수 있는 내용이 바람직 하다고 생각한다**

## **📚 실행관례**

> 특정 실행 관례를 사용하지 않는다는 이유로 누군가를 프로페셔널하지 않다고 성급하게 폄하해서는 안 된다. 그들이 사용 중인 실행 관례가 무엇인지 물어보고 당신이 사용하고자 하는 실행 관례와 비교해서 그들의 것이 어떤 점에서 더 나은지 찾아보아야 한다
>
>
> 📕 295p 0번째 (15장)
>

### **🧐 : 어떤 기술이나 방법론을 사용할때는 장,단점을 명확하게 인지하고 사용하는게 중요하다고 생각한다**

## **📚 리팩토링과 디자인 패턴**

> 패턴이 먼저가 아니다. 내가 좋아하는 패턴에 문제를 끼워 맞추기 전에, 문제에 적합한 리펙토링을 단순한 설계와 SOLID 원칙을 따라서 먼저 시도해야 한다. 그 다음에 리펙토링으로 만들어진 솔류션이 특정 디자인 패턴과 거의 동일하다면 그 패턴을 지향하도록 리펙토링할 수도 있다.
>
>
> 📕 305p 12번째 (15장)
>

### **🧐 : 디자인 패턴을 적용해보기전에 SOLID 원칙을 준수해서 코드를 작성했는지 한번 더 체크하는 습관을 들이는것도 좋을것 같다**

## **📚 장인정신과 실용주의**

> “이제 아키텍처가 정의되었으니 비즈니스 담당에게 요구사항이 무엇인지 물어봅시다”라고 했다. 지금 생각해보면 순서가 완전히 뒤바뀐 어리석은 업무 방식이다
…
실용주의가 없는 장인정신은 장인정신이 아니다. 장인이 가장 중요하게 초점을 맞추는 것은 고객의 만족이다. 품질은 물론이고 시간과 비용도 고객만족을 위한 구성요소다. 고객에게 가치를 전달할 수없다면 잘 작성된 코드라고 할 수 없다
>
>
> 📕 305p 24번째 (15장)
>

### **🧐 : 공감가는 말이다.. 소프트웨어의 핵심은 고객에게 가치를 제공하는것이 무엇보다 우선시 되어야 한다고 생각한다**

## **📚 장인정신**

> 장인으로서 우리의 역할은 특별히 이슈가 되지 않을 정도까지 품질 비용을 낮추는 것이다. 그렇게 하기 위해서는 좋은 실행 관례들을 마스터하고 실용주의적인 입장을 취할 필요가 있다. 서로 다른 맥락에서 각각의 실행 관례들이 어떤 가치가 있는지 이해해야 한다. 장인과 함께 일하는 고객이라면 품질에 대해서는 걱정을 하지 않아야 한다.
>
>
> 📕 307p 8번째 (15장)
>

### **🧐 : 특별히 이슈가 되지 않는 선에서 비용을 낮춘다는 문장이 핵심 포인트라고 생각한다**

## **📚 커리어 만들어 나가기**

> 나는 일을 선택하기 전에 아래와 같은 질문들을 스스로에게 던졌다
> 
> - 나의 커리어로부터 나는 무엇을 원하는가?
> - 그것을 성취하기 위한 다음 단계는 무엇인가?
> - 이 일은 나의 커리어 방향과 합치하는가?
> - 내가 이 회사에 줄 수 있는 가치의 양은 얼마나 되는가?
> - 그러한 투자에 대한 이익은 무엇인가?
> - 그러한 투자는 대략적으로 얼마 동안 지속되어야 하는가?
> - 내가 되고자 하는 프로페셔널에 이르는 데 이 일은 어떻게 도움이 되는가?
> - 이 일에서 나는 자율성, 통달, 목적의식을 가질 수 있나?
> - 나의 고용주와 생산적인 동반자 관계를 맺을 수 있나? 양측 모두 가치 얻고 행복할 수 있나?
>
>
> 📕 316p 1번째 (16장)
>

### **🧐 : 커리어를 만들어감에 있어서 한번쯤 생각해보면 좋을 내용이라 남겨두게 되었다**

---

# 📌 이해가 가지 않았던 내용

## **📚 단순하고 빠른 솔루션**

> 이 사례에서는 비즈니스 담당이 원하는 것을 찾아낼 수 있도록 그들이 생각을 바꿀 때마다 다른 부작용 없이 최대한 빨리 코드를 수정할 수 있는 방법을 고안하고 실행하였다. 이를 실행할 때 TDD와 지속적인 통합, 페어 프로그래밍은 핵심 요소였다
…
소프트웨어 프로젝트에서 예측 못한 변경의 양 자체는 문제가 아니다. 문제는 그러한 변화를 따라갈 수 있는 역량의 부족이다. 잘 작성된 소프트웨어는 고객에게 가치를 제공하기 위한 수단이다
>
>
> 📕 299p 3번째 (15장)
>

### **🧐 : 테스트 코드는 요구사항을 정의하는 부분인데 요구사항이 계속 바뀌면 테스트 코드 전체를 바꾸고 구현로직도 바꿔야 하는데 괜찮은걸까…?**

---

# 📌 논의해보고 싶었던 내용

## **📚 패턴을 위한 리팩토링**

> 추상화를 도입할 때마다 즉, 간접처리 단계가 추가될 때마다 비용이 발생한다. 이전에 순서대로 읽기만 하면 쉽게 이해되던 코드들이(간접 호출도 없고 급여처리 방식도 하나뿐인), 이제는 좀더 이해하기 어려워졌다. 이제는 런타임에 어떤 급여 방식이 사용될지 직접적으로 알 수가 없다. 설정 정보나 팩토리 클래스를 봐야만 알 수가 있다.
당장의 합당한 이유 없이 단지 ‘미래를 대비해야 한다’는 모호한 전제로, 초기부터 추상화를 하면 애플리케이션이 엉망이 된다.
애플리케이션이 진화 및 변경할 수 있도록 모든 가승성에 대비하는 것을 똑똑한 대응이라고 생각할 수도 있다. 진실은, 반대로 매우 바보같은 짓이다
>
>
> 📕 304p 14번째 (15장)
>

### **🧐 : 항상 딜레마인것 같다.. 적당한 추상화.. 적당한 확장성을 고려하는 부분은.. 다른 분들은 실무에서 어떤 기준으로 추상화를 도입하는지 궁금합니다요!**

## **📚 범용코드**

> 범용 코드는 확장성이 더 좋을지는 몰라도 특정된 코드보다 더 복잡하다. 무조건적으로 범용 코드를 추구해서는 안 된다. 대신 주어진 문제에만 특정된 코드로 먼저 솔루션을 찾은 후 나중에 필요한 상황이 생겼을 때 범용화하는 것이 좋다
>
>
> 📕 305p 16번째 (15장)
>

### **🧐 : 범용 코드(커먼코드)는 최근에 많이 듣는 이슈로, 중복코드를 작성하더라도 지양하는게 더 좋지 않을까 하는 생각이 든다(라이브러리 이슈, 버전 호환 이슈 등등..)**